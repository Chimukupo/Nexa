# **System Design Document (SDD): Nexa**

Version: 1.0  
Status: Approved  
Date: October 26, 2023  
Author: Lead Systems Architect

## **1\. System Overview**

Nexa is a personal finance Progressive Web App (PWA) designed for granular financial tracking, focusing on net income calculation and account reconciliation.

### **1.1 High-Level Architecture**

The system follows a **Serverless, Client-Heavy Architecture**.

* **Client:** A Next.js 16 application hosted on Vercel. It handles UI rendering, state management (TanStack Query), and direct data binding.  
* **Backend:** Firebase (GCP) provides Authentication, NoSQL Database (Firestore), and Serverless logic (Cloud Functions).  
* **Infrastructure:** Orchestrated via a pnpm Monorepo to share Typescript configurations and UI components.

## **2\. Monorepo Structure & Configuration**

We will use **Turborepo** with **pnpm workspaces** to ensure strict boundary enforcement and build caching.

nexa-monorepo/  
├── apps/  
│   └── web/                 \# Next.js 16 App (The main product)  
├── packages/  
│   ├── ui/                  \# Shared UI (shadcn/ui components, Tailwind 4\)  
│   ├── db/                  \# Shared Firebase Admin/Client SDK setup (Optional)  
│   ├── validators/          \# Shared Zod schemas (Client & Cloud Functions)  
│   ├── eslint-config/       \# Shared Linting rules  
│   └── typescript-config/   \# Shared tsconfig.json  
├── firebase/                \# Firebase Rules, Indexes, and Functions code  
├── .github/                 \# CI/CD workflows  
├── pnpm-workspace.yaml  
└── turbo.json

### **2.1 Key Package Versions**

* **Runtime:** Node.js ≥ 20  
* **Manager:** pnpm@10.4.1  
* **Framework:** Next.js 16 (App Router) \+ React 19  
* **Styling:** Tailwind CSS 4 (@tailwindcss/postcss)

## **3\. Data Architecture (Firestore)**

Given the NoSQL nature of Firestore and the need for security, we will use a **Root-Level User Collection** pattern. All sensitive financial data is encapsulated within the user's document as sub-collections.

### **3.1 Entity Relationship Diagram (ERD)**

*Visualization of the Firestore NoSQL Schema:*

* **User** (Root)  
  * **Accounts** (Sub-collection)  
  * **Categories** (Sub-collection)  
  * **Transactions** (Sub-collection)  
  * **RecurringRules** (Sub-collection)

### **3.2 Schema Definitions**

1\. Users Collection (/users/{userId})  
Stores global preferences and profile data.  
type UserProfile \= {  
  uid: string;  
  email: string;  
  displayName: string;  
  currency: "ZMW" | "USD" | "GBP" | "ZAR"; // Default ZMW  
  fiscalType: "SALARIED" | "FREELANCE";  
  createdAt: Timestamp;  
  onboardingCompleted: boolean;  
}

2\. Accounts Sub-collection (/users/{userId}/accounts/{accountId})  
Represents state (where money is).  
type Account \= {  
  id: string;  
  name: string; // e.g., "Stanbic Bank", "Mobile Money"  
  type: "CASH" | "BANK" | "MOBILE\_MONEY" | "SAVINGS";  
  currentBalance: number; // Updated via triggers or client transactions  
  isArchived: boolean;  
}

3\. Categories Sub-collection (/users/{userId}/categories/{categoryId})  
Used for budgeting and tagging.  
type Category \= {  
  id: string;  
  name: string; // e.g., "Groceries", "Rent"  
  type: "NEEDS" | "WANTS" | "SAVINGS" | "INCOME"; // Maps to 50/30/20  
  color: string; // Hex code for UI  
  icon: string; // Lucide icon name  
  monthlyBudgetCap?: number; // Optional limit  
}

4\. Transactions Sub-collection (/users/{userId}/transactions/{txnId})  
The core ledger.  
type Transaction \= {  
  id: string;  
  amount: number;  
  type: "INCOME" | "EXPENSE" | "TRANSFER";  
  accountId: string; // Foreign Key to Accounts  
  categoryId: string; // Foreign Key to Categories  
  date: Timestamp;  
  description?: string;  
  isRecurring: boolean; // Flag if generated by system  
  // Income Specifics  
  grossAmount?: number; // For detailed tax tracking  
  deductions?: number;  
}

5\. Recurring Rules Sub-collection (/users/{userId}/recurring\_rules/{ruleId})  
Engine configuration for auto-transactions.  
type RecurringRule \= {  
  id: string;  
  name: string; // "Monthly Salary", "Netflix"  
  amount: number;  
  type: "INCOME" | "EXPENSE";  
  cronExpressionOrDay: number; // e.g., 25 (25th of month)  
  accountId: string;  
  categoryId: string;  
  lastRunDate: Timestamp;  
}

## **4\. Component Architecture (Frontend)**

### **4.1 Tech Integration**

* **State Management:** TanStack Query (v5). We will use useQuery for fetching Firestore collections and useMutation for writes. This handles caching, deduping, and loading states.  
* **Forms:** React Hook Form combined with zod-resolver.  
* **Validation:** Schemas imported from @workspace/validators.

### **4.2 Key Component Tree**

RootLayout  
 ├── ThemeProvider (next-themes)  
 ├── QueryClientProvider (TanStack)  
 ├── AuthProvider (Firebase Context)  
 └── Toaster (shadcn/ui)  
      │  
      ├── (Public)  
      │    └── LoginPage / SignupPage  
      │  
      └── (Protected \- DashboardLayout)  
           ├── AppSidebar (Collapsible)  
           └── PageContent  
                ├── DashboardPage (Widgets: BalanceCard, ExpenseChart)  
                ├── TransactionsPage (DataTable with Filters)  
                ├── BudgetPage (Progress Bars)  
                └── SettingsPage

### **4.3 Shared UI (packages/ui)**

We will export shadcn/ui components tailored for Nexa:

* ui/card: For Account summaries.  
* ui/data-table: For transaction history (sorting/filtering).  
* ui/form: Wrapped RHF components.  
* ui/charts: Recharts wrapper for visual analytics.

## **5\. Backend Logic & Cloud Functions**

Since Nexa uses a "Serverless" backend, complex logic resides in **Cloud Functions** (triggered by Firestore events or Schedule).

### **5.1 The "Balance Keeper" (Firestore Trigger)**

* **Trigger:** onWrite to /users/{uid}/transactions/{txnId}  
* **Logic:**  
  1. Get oldValue and newValue.  
  2. Calculate delta.  
  3. Atomically increment/decrement the currentBalance in the referenced accounts/{accountId} document.  
* **Benefit:** Ensures Account Balance is always in sync without expensive client-side recalculations of full history.

### **5.2 The "Recurring Engine" (Scheduled Function)**

* **Trigger:** Google Cloud Scheduler (Daily at 00:00 UTC).  
* **Logic:**  
  1. Query all recurring\_rules where dayOfMonth \== currentDay AND lastRunDate \!= today.  
  2. Batch create Transaction documents for these rules.  
  3. Update lastRunDate on the rule.

## **6\. Security & Validation Design**

### **6.1 Authentication**

* **Provider:** Firebase Auth (Email/Password).  
* **Session:** Firebase ID Tokens handled via client SDK.  
* **Middleware:** Next.js Middleware (middleware.ts) checks for auth cookies to protect /dashboard/\* routes (Server-Side Redirects).

### **6.2 Firestore Security Rules**

Strict request.auth.uid matching is enforced.

match /users/{userId}/{document=\*\*} {  
  allow read, write: if request.auth \!= null && request.auth.uid \== userId;  
}

### **6.3 Data Validation (Zod)**

We use a shared Zod package (packages/validators) to ensure type safety travels from Form \-\> API \-\> Database.

// packages/validators/src/transaction.ts  
export const createTransactionSchema \= z.object({  
  amount: z.number().positive(),  
  categoryId: z.string().min(1),  
  accountId: z.string().min(1),  
  date: z.date(),  
  // ...  
});

## **7\. Testing Strategy**

* **Unit Testing (Vitest):** Focus on utility functions (e.g., Net Pay calculators, Date formatters) and isolated UI components in packages/ui.  
* **End-to-End (Playwright):**  
  * **Critical Path 1:** User Login \-\> Dashboard Load.  
  * **Critical Path 2:** Create Transaction \-\> Verify Balance Update on Dashboard.  
  * **Critical Path 3:** Create Budget \-\> Verify Progress Bar update.

## **8\. Deployment Pipeline (CI/CD)**

1. **Commit:** Developer pushes code to GitHub.  
2. **CI (GitHub Actions):**  
   * pnpm install  
   * turbo lint type-check test (Runs mainly on changed workspaces).  
3. **CD (Vercel):**  
   * Automatically deploys apps/web.  
   * Environment variables synced via Vercel Project Settings.  
4. **CD (Firebase):**  
   * GitHub Action deploys firestore.rules, storage.rules, and functions on merge to main.